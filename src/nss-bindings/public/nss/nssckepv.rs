/* automatically generated by rust-bindgen */

#![allow(dead_code,
         non_camel_case_types,
         non_upper_case_globals,
         non_snake_case)]
pub type ptrdiff_t = isize;
pub type size_t = usize;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __clang_max_align_nonce2: ::std::os::raw::c_double,
}
impl ::std::default::Default for max_align_t {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type PRUint8 = ::std::os::raw::c_uchar;
pub type PRInt8 = ::std::os::raw::c_char;
pub type PRUint16 = ::std::os::raw::c_ushort;
pub type PRInt16 = ::std::os::raw::c_short;
pub type PRUint32 = ::std::os::raw::c_uint;
pub type PRInt32 = ::std::os::raw::c_int;
pub type PRInt64 = ::std::os::raw::c_long;
pub type PRUint64 = ::std::os::raw::c_ulong;
pub type PRIntn = ::std::os::raw::c_int;
pub type PRUintn = ::std::os::raw::c_uint;
pub type PRFloat64 = ::std::os::raw::c_double;
pub type PRSize = size_t;
pub type PROffset32 = PRInt32;
pub type PROffset64 = PRInt64;
pub type PRPtrdiff = ptrdiff_t;
pub type PRUptrdiff = ::std::os::raw::c_ulong;
pub type PRBool = PRIntn;
pub type PRPackedBool = PRUint8;
#[derive(Copy, Clone)]
#[repr(i32)]
#[derive(Debug)]
pub enum PRStatus { PR_FAILURE = -1, PR_SUCCESS = 0, }
pub type PRUnichar = PRUint16;
pub type PRWord = ::std::os::raw::c_long;
pub type PRUword = ::std::os::raw::c_ulong;
pub type uintn = PRUintn;
pub type intn = PRIntn;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_char;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
impl ::std::default::Default for __fsid_t {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __qaddr_t = *mut __quad_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type off_t = __off_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type ssize_t = isize;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type time_t = __time_t;
pub type clockid_t = __clockid_t;
pub type timer_t = __timer_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint_ = ::std::os::raw::c_uint;
pub type int8_t = i8;
pub type int16_t = i16;
pub type int32_t = i32;
pub type int64_t = i64;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulong;
pub type register_t = ::std::os::raw::c_long;
pub type __sig_atomic_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
impl ::std::default::Default for __sigset_t {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
impl ::std::default::Default for timespec {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
impl ::std::default::Default for timeval {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
impl ::std::default::Default for fd_set {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type fd_mask = __fd_mask;
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy)]
pub struct pthread_attr_t {
    pub _bindgen_data_: [u64; 7usize],
}
impl pthread_attr_t {
    pub unsafe fn __size(&mut self)
     -> *mut [::std::os::raw::c_char; 56usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __align(&mut self) -> *mut ::std::os::raw::c_long {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for pthread_attr_t {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for pthread_attr_t {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
impl ::std::default::Default for __pthread_internal_list {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Copy)]
pub struct pthread_mutex_t {
    pub _bindgen_data_: [u64; 5usize],
}
impl pthread_mutex_t {
    pub unsafe fn __data(&mut self) -> *mut __pthread_mutex_s {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __size(&mut self)
     -> *mut [::std::os::raw::c_char; 40usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __align(&mut self) -> *mut ::std::os::raw::c_long {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for pthread_mutex_t {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for pthread_mutex_t {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
impl ::std::default::Default for __pthread_mutex_s {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct pthread_mutexattr_t {
    pub _bindgen_data_: [u32; 1usize],
}
impl pthread_mutexattr_t {
    pub unsafe fn __size(&mut self) -> *mut [::std::os::raw::c_char; 4usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __align(&mut self) -> *mut ::std::os::raw::c_int {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::default::Default for pthread_mutexattr_t {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct pthread_cond_t {
    pub _bindgen_data_: [u64; 6usize],
}
impl pthread_cond_t {
    pub unsafe fn __data(&mut self) -> *mut Struct_Unnamed1 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __size(&mut self)
     -> *mut [::std::os::raw::c_char; 48usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __align(&mut self) -> *mut ::std::os::raw::c_longlong {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for pthread_cond_t {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for pthread_cond_t {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct Struct_Unnamed1 {
    pub __lock: ::std::os::raw::c_int,
    pub __futex: ::std::os::raw::c_uint,
    pub __total_seq: ::std::os::raw::c_ulonglong,
    pub __wakeup_seq: ::std::os::raw::c_ulonglong,
    pub __woken_seq: ::std::os::raw::c_ulonglong,
    pub __mutex: *mut ::std::os::raw::c_void,
    pub __nwaiters: ::std::os::raw::c_uint,
    pub __broadcast_seq: ::std::os::raw::c_uint,
}
impl ::std::default::Default for Struct_Unnamed1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct pthread_condattr_t {
    pub _bindgen_data_: [u32; 1usize],
}
impl pthread_condattr_t {
    pub unsafe fn __size(&mut self) -> *mut [::std::os::raw::c_char; 4usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __align(&mut self) -> *mut ::std::os::raw::c_int {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::default::Default for pthread_condattr_t {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy)]
pub struct pthread_rwlock_t {
    pub _bindgen_data_: [u64; 7usize],
}
impl pthread_rwlock_t {
    pub unsafe fn __data(&mut self) -> *mut Struct_Unnamed2 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __size(&mut self)
     -> *mut [::std::os::raw::c_char; 56usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __align(&mut self) -> *mut ::std::os::raw::c_long {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for pthread_rwlock_t {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for pthread_rwlock_t {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct Struct_Unnamed2 {
    pub __lock: ::std::os::raw::c_int,
    pub __nr_readers: ::std::os::raw::c_uint,
    pub __readers_wakeup: ::std::os::raw::c_uint,
    pub __writer_wakeup: ::std::os::raw::c_uint,
    pub __nr_readers_queued: ::std::os::raw::c_uint,
    pub __nr_writers_queued: ::std::os::raw::c_uint,
    pub __writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_char,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
impl ::std::default::Default for Struct_Unnamed2 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct pthread_rwlockattr_t {
    pub _bindgen_data_: [u64; 1usize],
}
impl pthread_rwlockattr_t {
    pub unsafe fn __size(&mut self) -> *mut [::std::os::raw::c_char; 8usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __align(&mut self) -> *mut ::std::os::raw::c_long {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::default::Default for pthread_rwlockattr_t {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct pthread_barrier_t {
    pub _bindgen_data_: [u64; 4usize],
}
impl pthread_barrier_t {
    pub unsafe fn __size(&mut self)
     -> *mut [::std::os::raw::c_char; 32usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __align(&mut self) -> *mut ::std::os::raw::c_long {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::default::Default for pthread_barrier_t {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct pthread_barrierattr_t {
    pub _bindgen_data_: [u32; 1usize],
}
impl pthread_barrierattr_t {
    pub unsafe fn __size(&mut self) -> *mut [::std::os::raw::c_char; 4usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __align(&mut self) -> *mut ::std::os::raw::c_int {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::default::Default for pthread_barrierattr_t {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type uint64 = PRUint64;
pub type uint32 = PRUint32;
pub type uint16 = PRUint16;
pub type uint8 = PRUint8;
pub type int64 = PRInt64;
pub type int32 = PRInt32;
pub type int16 = PRInt16;
pub type int8 = PRInt8;
pub type float64 = PRFloat64;
pub type uptrdiff_t = PRUptrdiff;
pub type uprword_t = PRUword;
pub type prword_t = PRWord;
pub type CK_BYTE = ::std::os::raw::c_uchar;
pub type CK_CHAR = CK_BYTE;
pub type CK_UTF8CHAR = CK_BYTE;
pub type CK_BBOOL = CK_BYTE;
pub type CK_ULONG = ::std::os::raw::c_ulong;
pub type CK_LONG = ::std::os::raw::c_long;
pub type CK_FLAGS = CK_ULONG;
pub type CK_BYTE_PTR = *mut CK_BYTE;
pub type CK_CHAR_PTR = *mut CK_CHAR;
pub type CK_UTF8CHAR_PTR = *mut CK_UTF8CHAR;
pub type CK_ULONG_PTR = *mut CK_ULONG;
pub type CK_VOID_PTR = *mut ::std::os::raw::c_void;
pub type CK_VOID_PTR_PTR = *mut CK_VOID_PTR;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct CK_VERSION {
    pub major: CK_BYTE,
    pub minor: CK_BYTE,
}
impl ::std::default::Default for CK_VERSION {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CK_VERSION_PTR = *mut CK_VERSION;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct CK_INFO {
    pub cryptokiVersion: CK_VERSION,
    pub manufacturerID: [CK_UTF8CHAR; 32usize],
    pub flags: CK_FLAGS,
    pub libraryDescription: [CK_UTF8CHAR; 32usize],
    pub libraryVersion: CK_VERSION,
}
impl ::std::default::Default for CK_INFO {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CK_INFO_PTR = *mut CK_INFO;
pub type CK_NOTIFICATION = CK_ULONG;
pub type CK_SLOT_ID = CK_ULONG;
pub type CK_SLOT_ID_PTR = *mut CK_SLOT_ID;
#[repr(C)]
#[derive(Copy)]
pub struct CK_SLOT_INFO {
    pub slotDescription: [CK_UTF8CHAR; 64usize],
    pub manufacturerID: [CK_UTF8CHAR; 32usize],
    pub flags: CK_FLAGS,
    pub hardwareVersion: CK_VERSION,
    pub firmwareVersion: CK_VERSION,
}
impl ::std::clone::Clone for CK_SLOT_INFO {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for CK_SLOT_INFO {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CK_SLOT_INFO_PTR = *mut CK_SLOT_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct CK_TOKEN_INFO {
    pub label: [CK_UTF8CHAR; 32usize],
    pub manufacturerID: [CK_UTF8CHAR; 32usize],
    pub model: [CK_UTF8CHAR; 16usize],
    pub serialNumber: [CK_CHAR; 16usize],
    pub flags: CK_FLAGS,
    pub ulMaxSessionCount: CK_ULONG,
    pub ulSessionCount: CK_ULONG,
    pub ulMaxRwSessionCount: CK_ULONG,
    pub ulRwSessionCount: CK_ULONG,
    pub ulMaxPinLen: CK_ULONG,
    pub ulMinPinLen: CK_ULONG,
    pub ulTotalPublicMemory: CK_ULONG,
    pub ulFreePublicMemory: CK_ULONG,
    pub ulTotalPrivateMemory: CK_ULONG,
    pub ulFreePrivateMemory: CK_ULONG,
    pub hardwareVersion: CK_VERSION,
    pub firmwareVersion: CK_VERSION,
    pub utcTime: [CK_CHAR; 16usize],
}
impl ::std::default::Default for CK_TOKEN_INFO {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CK_TOKEN_INFO_PTR = *mut CK_TOKEN_INFO;
pub type CK_SESSION_HANDLE = CK_ULONG;
pub type CK_SESSION_HANDLE_PTR = *mut CK_SESSION_HANDLE;
pub type CK_USER_TYPE = CK_ULONG;
pub type CK_STATE = CK_ULONG;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct CK_SESSION_INFO {
    pub slotID: CK_SLOT_ID,
    pub state: CK_STATE,
    pub flags: CK_FLAGS,
    pub ulDeviceError: CK_ULONG,
}
impl ::std::default::Default for CK_SESSION_INFO {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CK_SESSION_INFO_PTR = *mut CK_SESSION_INFO;
pub type CK_OBJECT_HANDLE = CK_ULONG;
pub type CK_OBJECT_HANDLE_PTR = *mut CK_OBJECT_HANDLE;
pub type CK_OBJECT_CLASS = CK_ULONG;
pub type CK_OBJECT_CLASS_PTR = *mut CK_OBJECT_CLASS;
pub type CK_HW_FEATURE_TYPE = CK_ULONG;
pub type CK_KEY_TYPE = CK_ULONG;
pub type CK_CERTIFICATE_TYPE = CK_ULONG;
pub type CK_ATTRIBUTE_TYPE = CK_ULONG;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct CK_ATTRIBUTE {
    pub type_: CK_ATTRIBUTE_TYPE,
    pub pValue: CK_VOID_PTR,
    pub ulValueLen: CK_ULONG,
}
impl ::std::default::Default for CK_ATTRIBUTE {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CK_ATTRIBUTE_PTR = *mut CK_ATTRIBUTE;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct CK_DATE {
    pub year: [CK_CHAR; 4usize],
    pub month: [CK_CHAR; 2usize],
    pub day: [CK_CHAR; 2usize],
}
impl ::std::default::Default for CK_DATE {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CK_MECHANISM_TYPE = CK_ULONG;
pub type CK_MECHANISM_TYPE_PTR = *mut CK_MECHANISM_TYPE;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct CK_MECHANISM {
    pub mechanism: CK_MECHANISM_TYPE,
    pub pParameter: CK_VOID_PTR,
    pub ulParameterLen: CK_ULONG,
}
impl ::std::default::Default for CK_MECHANISM {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CK_MECHANISM_PTR = *mut CK_MECHANISM;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct CK_MECHANISM_INFO {
    pub ulMinKeySize: CK_ULONG,
    pub ulMaxKeySize: CK_ULONG,
    pub flags: CK_FLAGS,
}
impl ::std::default::Default for CK_MECHANISM_INFO {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CK_MECHANISM_INFO_PTR = *mut CK_MECHANISM_INFO;
pub type CK_RV = CK_ULONG;
pub type CK_NOTIFY =
    ::std::option::Option<extern "C" fn(hSession: CK_SESSION_HANDLE,
                                        event: CK_NOTIFICATION,
                                        pApplication: CK_VOID_PTR) -> CK_RV>;
pub type CK_FUNCTION_LIST_PTR = *mut CK_FUNCTION_LIST;
pub type CK_FUNCTION_LIST_PTR_PTR = *mut CK_FUNCTION_LIST_PTR;
pub type CK_CREATEMUTEX =
    ::std::option::Option<extern "C" fn(ppMutex: CK_VOID_PTR_PTR) -> CK_RV>;
pub type CK_DESTROYMUTEX =
    ::std::option::Option<extern "C" fn(pMutex: CK_VOID_PTR) -> CK_RV>;
pub type CK_LOCKMUTEX =
    ::std::option::Option<extern "C" fn(pMutex: CK_VOID_PTR) -> CK_RV>;
pub type CK_UNLOCKMUTEX =
    ::std::option::Option<extern "C" fn(pMutex: CK_VOID_PTR) -> CK_RV>;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct CK_C_INITIALIZE_ARGS {
    pub CreateMutex: CK_CREATEMUTEX,
    pub DestroyMutex: CK_DESTROYMUTEX,
    pub LockMutex: CK_LOCKMUTEX,
    pub UnlockMutex: CK_UNLOCKMUTEX,
    pub flags: CK_FLAGS,
    pub LibraryParameters: *mut CK_CHAR_PTR,
    pub pReserved: CK_VOID_PTR,
}
impl ::std::default::Default for CK_C_INITIALIZE_ARGS {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CK_C_INITIALIZE_ARGS_PTR = *mut CK_C_INITIALIZE_ARGS;
pub type CK_RSA_PKCS_MGF_TYPE = CK_ULONG;
pub type CK_RSA_PKCS_MGF_TYPE_PTR = *mut CK_RSA_PKCS_MGF_TYPE;
pub type CK_RSA_PKCS_OAEP_SOURCE_TYPE = CK_ULONG;
pub type CK_RSA_PKCS_OAEP_SOURCE_TYPE_PTR = *mut CK_RSA_PKCS_OAEP_SOURCE_TYPE;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct CK_RSA_PKCS_OAEP_PARAMS {
    pub hashAlg: CK_MECHANISM_TYPE,
    pub mgf: CK_RSA_PKCS_MGF_TYPE,
    pub source: CK_RSA_PKCS_OAEP_SOURCE_TYPE,
    pub pSourceData: CK_VOID_PTR,
    pub ulSourceDataLen: CK_ULONG,
}
impl ::std::default::Default for CK_RSA_PKCS_OAEP_PARAMS {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CK_RSA_PKCS_OAEP_PARAMS_PTR = *mut CK_RSA_PKCS_OAEP_PARAMS;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct CK_RSA_PKCS_PSS_PARAMS {
    pub hashAlg: CK_MECHANISM_TYPE,
    pub mgf: CK_RSA_PKCS_MGF_TYPE,
    pub sLen: CK_ULONG,
}
impl ::std::default::Default for CK_RSA_PKCS_PSS_PARAMS {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CK_RSA_PKCS_PSS_PARAMS_PTR = *mut CK_RSA_PKCS_PSS_PARAMS;
pub type CK_EC_KDF_TYPE = CK_ULONG;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct CK_ECDH1_DERIVE_PARAMS {
    pub kdf: CK_EC_KDF_TYPE,
    pub ulSharedDataLen: CK_ULONG,
    pub pSharedData: CK_BYTE_PTR,
    pub ulPublicDataLen: CK_ULONG,
    pub pPublicData: CK_BYTE_PTR,
}
impl ::std::default::Default for CK_ECDH1_DERIVE_PARAMS {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CK_ECDH1_DERIVE_PARAMS_PTR = *mut CK_ECDH1_DERIVE_PARAMS;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct CK_ECDH2_DERIVE_PARAMS {
    pub kdf: CK_EC_KDF_TYPE,
    pub ulSharedDataLen: CK_ULONG,
    pub pSharedData: CK_BYTE_PTR,
    pub ulPublicDataLen: CK_ULONG,
    pub pPublicData: CK_BYTE_PTR,
    pub ulPrivateDataLen: CK_ULONG,
    pub hPrivateData: CK_OBJECT_HANDLE,
    pub ulPublicDataLen2: CK_ULONG,
    pub pPublicData2: CK_BYTE_PTR,
}
impl ::std::default::Default for CK_ECDH2_DERIVE_PARAMS {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CK_ECDH2_DERIVE_PARAMS_PTR = *mut CK_ECDH2_DERIVE_PARAMS;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct CK_ECMQV_DERIVE_PARAMS {
    pub kdf: CK_EC_KDF_TYPE,
    pub ulSharedDataLen: CK_ULONG,
    pub pSharedData: CK_BYTE_PTR,
    pub ulPublicDataLen: CK_ULONG,
    pub pPublicData: CK_BYTE_PTR,
    pub ulPrivateDataLen: CK_ULONG,
    pub hPrivateData: CK_OBJECT_HANDLE,
    pub ulPublicDataLen2: CK_ULONG,
    pub pPublicData2: CK_BYTE_PTR,
    pub publicKey: CK_OBJECT_HANDLE,
}
impl ::std::default::Default for CK_ECMQV_DERIVE_PARAMS {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CK_ECMQV_DERIVE_PARAMS_PTR = *mut CK_ECMQV_DERIVE_PARAMS;
pub type CK_X9_42_DH_KDF_TYPE = CK_ULONG;
pub type CK_X9_42_DH_KDF_TYPE_PTR = *mut CK_X9_42_DH_KDF_TYPE;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct CK_X9_42_DH1_DERIVE_PARAMS {
    pub kdf: CK_X9_42_DH_KDF_TYPE,
    pub ulOtherInfoLen: CK_ULONG,
    pub pOtherInfo: CK_BYTE_PTR,
    pub ulPublicDataLen: CK_ULONG,
    pub pPublicData: CK_BYTE_PTR,
}
impl ::std::default::Default for CK_X9_42_DH1_DERIVE_PARAMS {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CK_X9_42_DH1_DERIVE_PARAMS_PTR = *mut CK_X9_42_DH1_DERIVE_PARAMS;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct CK_X9_42_DH2_DERIVE_PARAMS {
    pub kdf: CK_X9_42_DH_KDF_TYPE,
    pub ulOtherInfoLen: CK_ULONG,
    pub pOtherInfo: CK_BYTE_PTR,
    pub ulPublicDataLen: CK_ULONG,
    pub pPublicData: CK_BYTE_PTR,
    pub ulPrivateDataLen: CK_ULONG,
    pub hPrivateData: CK_OBJECT_HANDLE,
    pub ulPublicDataLen2: CK_ULONG,
    pub pPublicData2: CK_BYTE_PTR,
}
impl ::std::default::Default for CK_X9_42_DH2_DERIVE_PARAMS {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CK_X9_42_DH2_DERIVE_PARAMS_PTR = *mut CK_X9_42_DH2_DERIVE_PARAMS;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct CK_X9_42_MQV_DERIVE_PARAMS {
    pub kdf: CK_X9_42_DH_KDF_TYPE,
    pub ulOtherInfoLen: CK_ULONG,
    pub pOtherInfo: CK_BYTE_PTR,
    pub ulPublicDataLen: CK_ULONG,
    pub pPublicData: CK_BYTE_PTR,
    pub ulPrivateDataLen: CK_ULONG,
    pub hPrivateData: CK_OBJECT_HANDLE,
    pub ulPublicDataLen2: CK_ULONG,
    pub pPublicData2: CK_BYTE_PTR,
    pub publicKey: CK_OBJECT_HANDLE,
}
impl ::std::default::Default for CK_X9_42_MQV_DERIVE_PARAMS {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CK_X9_42_MQV_DERIVE_PARAMS_PTR = *mut CK_X9_42_MQV_DERIVE_PARAMS;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct CK_KEA_DERIVE_PARAMS {
    pub isSender: CK_BBOOL,
    pub ulRandomLen: CK_ULONG,
    pub pRandomA: CK_BYTE_PTR,
    pub pRandomB: CK_BYTE_PTR,
    pub ulPublicDataLen: CK_ULONG,
    pub pPublicData: CK_BYTE_PTR,
}
impl ::std::default::Default for CK_KEA_DERIVE_PARAMS {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CK_KEA_DERIVE_PARAMS_PTR = *mut CK_KEA_DERIVE_PARAMS;
pub type CK_RC2_PARAMS = CK_ULONG;
pub type CK_RC2_PARAMS_PTR = *mut CK_RC2_PARAMS;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct CK_RC2_CBC_PARAMS {
    pub ulEffectiveBits: CK_ULONG,
    pub iv: [CK_BYTE; 8usize],
}
impl ::std::default::Default for CK_RC2_CBC_PARAMS {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CK_RC2_CBC_PARAMS_PTR = *mut CK_RC2_CBC_PARAMS;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct CK_RC2_MAC_GENERAL_PARAMS {
    pub ulEffectiveBits: CK_ULONG,
    pub ulMacLength: CK_ULONG,
}
impl ::std::default::Default for CK_RC2_MAC_GENERAL_PARAMS {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CK_RC2_MAC_GENERAL_PARAMS_PTR = *mut CK_RC2_MAC_GENERAL_PARAMS;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct CK_RC5_PARAMS {
    pub ulWordsize: CK_ULONG,
    pub ulRounds: CK_ULONG,
}
impl ::std::default::Default for CK_RC5_PARAMS {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CK_RC5_PARAMS_PTR = *mut CK_RC5_PARAMS;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct CK_RC5_CBC_PARAMS {
    pub ulWordsize: CK_ULONG,
    pub ulRounds: CK_ULONG,
    pub pIv: CK_BYTE_PTR,
    pub ulIvLen: CK_ULONG,
}
impl ::std::default::Default for CK_RC5_CBC_PARAMS {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CK_RC5_CBC_PARAMS_PTR = *mut CK_RC5_CBC_PARAMS;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct CK_RC5_MAC_GENERAL_PARAMS {
    pub ulWordsize: CK_ULONG,
    pub ulRounds: CK_ULONG,
    pub ulMacLength: CK_ULONG,
}
impl ::std::default::Default for CK_RC5_MAC_GENERAL_PARAMS {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CK_RC5_MAC_GENERAL_PARAMS_PTR = *mut CK_RC5_MAC_GENERAL_PARAMS;
pub type CK_MAC_GENERAL_PARAMS = CK_ULONG;
pub type CK_MAC_GENERAL_PARAMS_PTR = *mut CK_MAC_GENERAL_PARAMS;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct CK_DES_CBC_ENCRYPT_DATA_PARAMS {
    pub iv: [CK_BYTE; 8usize],
    pub pData: CK_BYTE_PTR,
    pub length: CK_ULONG,
}
impl ::std::default::Default for CK_DES_CBC_ENCRYPT_DATA_PARAMS {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CK_DES_CBC_ENCRYPT_DATA_PARAMS_PTR =
    *mut CK_DES_CBC_ENCRYPT_DATA_PARAMS;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct CK_AES_CBC_ENCRYPT_DATA_PARAMS {
    pub iv: [CK_BYTE; 16usize],
    pub pData: CK_BYTE_PTR,
    pub length: CK_ULONG,
}
impl ::std::default::Default for CK_AES_CBC_ENCRYPT_DATA_PARAMS {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CK_AES_CBC_ENCRYPT_DATA_PARAMS_PTR =
    *mut CK_AES_CBC_ENCRYPT_DATA_PARAMS;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct CK_AES_CTR_PARAMS {
    pub ulCounterBits: CK_ULONG,
    pub cb: [CK_BYTE; 16usize],
}
impl ::std::default::Default for CK_AES_CTR_PARAMS {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CK_AES_CTR_PARAMS_PTR = *mut CK_AES_CTR_PARAMS;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct CK_GCM_PARAMS {
    pub pIv: CK_BYTE_PTR,
    pub ulIvLen: CK_ULONG,
    pub pAAD: CK_BYTE_PTR,
    pub ulAADLen: CK_ULONG,
    pub ulTagBits: CK_ULONG,
}
impl ::std::default::Default for CK_GCM_PARAMS {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CK_GCM_PARAMS_PTR = *mut CK_GCM_PARAMS;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct CK_CCM_PARAMS {
    pub ulDataLen: CK_ULONG,
    pub pNonce: CK_BYTE_PTR,
    pub ulNonceLen: CK_ULONG,
    pub pAAD: CK_BYTE_PTR,
    pub ulAADLen: CK_ULONG,
    pub ulMACLen: CK_ULONG,
}
impl ::std::default::Default for CK_CCM_PARAMS {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CK_CCM_PARAMS_PTR = *mut CK_CCM_PARAMS;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct CK_SKIPJACK_PRIVATE_WRAP_PARAMS {
    pub ulPasswordLen: CK_ULONG,
    pub pPassword: CK_BYTE_PTR,
    pub ulPublicDataLen: CK_ULONG,
    pub pPublicData: CK_BYTE_PTR,
    pub ulPAndGLen: CK_ULONG,
    pub ulQLen: CK_ULONG,
    pub ulRandomLen: CK_ULONG,
    pub pRandomA: CK_BYTE_PTR,
    pub pPrimeP: CK_BYTE_PTR,
    pub pBaseG: CK_BYTE_PTR,
    pub pSubprimeQ: CK_BYTE_PTR,
}
impl ::std::default::Default for CK_SKIPJACK_PRIVATE_WRAP_PARAMS {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CK_SKIPJACK_PRIVATE_WRAP_PTR = *mut CK_SKIPJACK_PRIVATE_WRAP_PARAMS;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct CK_SKIPJACK_RELAYX_PARAMS {
    pub ulOldWrappedXLen: CK_ULONG,
    pub pOldWrappedX: CK_BYTE_PTR,
    pub ulOldPasswordLen: CK_ULONG,
    pub pOldPassword: CK_BYTE_PTR,
    pub ulOldPublicDataLen: CK_ULONG,
    pub pOldPublicData: CK_BYTE_PTR,
    pub ulOldRandomLen: CK_ULONG,
    pub pOldRandomA: CK_BYTE_PTR,
    pub ulNewPasswordLen: CK_ULONG,
    pub pNewPassword: CK_BYTE_PTR,
    pub ulNewPublicDataLen: CK_ULONG,
    pub pNewPublicData: CK_BYTE_PTR,
    pub ulNewRandomLen: CK_ULONG,
    pub pNewRandomA: CK_BYTE_PTR,
}
impl ::std::default::Default for CK_SKIPJACK_RELAYX_PARAMS {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CK_SKIPJACK_RELAYX_PARAMS_PTR = *mut CK_SKIPJACK_RELAYX_PARAMS;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct CK_PBE_PARAMS {
    pub pInitVector: CK_BYTE_PTR,
    pub pPassword: CK_UTF8CHAR_PTR,
    pub ulPasswordLen: CK_ULONG,
    pub pSalt: CK_BYTE_PTR,
    pub ulSaltLen: CK_ULONG,
    pub ulIteration: CK_ULONG,
}
impl ::std::default::Default for CK_PBE_PARAMS {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CK_PBE_PARAMS_PTR = *mut CK_PBE_PARAMS;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct CK_KEY_WRAP_SET_OAEP_PARAMS {
    pub bBC: CK_BYTE,
    pub pX: CK_BYTE_PTR,
    pub ulXLen: CK_ULONG,
}
impl ::std::default::Default for CK_KEY_WRAP_SET_OAEP_PARAMS {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CK_KEY_WRAP_SET_OAEP_PARAMS_PTR = *mut CK_KEY_WRAP_SET_OAEP_PARAMS;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct CK_SSL3_RANDOM_DATA {
    pub pClientRandom: CK_BYTE_PTR,
    pub ulClientRandomLen: CK_ULONG,
    pub pServerRandom: CK_BYTE_PTR,
    pub ulServerRandomLen: CK_ULONG,
}
impl ::std::default::Default for CK_SSL3_RANDOM_DATA {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct CK_SSL3_MASTER_KEY_DERIVE_PARAMS {
    pub RandomInfo: CK_SSL3_RANDOM_DATA,
    pub pVersion: CK_VERSION_PTR,
}
impl ::std::default::Default for CK_SSL3_MASTER_KEY_DERIVE_PARAMS {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CK_SSL3_MASTER_KEY_DERIVE_PARAMS_PTR =
    *mut CK_SSL3_MASTER_KEY_DERIVE_PARAMS;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct CK_SSL3_KEY_MAT_OUT {
    pub hClientMacSecret: CK_OBJECT_HANDLE,
    pub hServerMacSecret: CK_OBJECT_HANDLE,
    pub hClientKey: CK_OBJECT_HANDLE,
    pub hServerKey: CK_OBJECT_HANDLE,
    pub pIVClient: CK_BYTE_PTR,
    pub pIVServer: CK_BYTE_PTR,
}
impl ::std::default::Default for CK_SSL3_KEY_MAT_OUT {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CK_SSL3_KEY_MAT_OUT_PTR = *mut CK_SSL3_KEY_MAT_OUT;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct CK_SSL3_KEY_MAT_PARAMS {
    pub ulMacSizeInBits: CK_ULONG,
    pub ulKeySizeInBits: CK_ULONG,
    pub ulIVSizeInBits: CK_ULONG,
    pub bIsExport: CK_BBOOL,
    pub RandomInfo: CK_SSL3_RANDOM_DATA,
    pub pReturnedKeyMaterial: CK_SSL3_KEY_MAT_OUT_PTR,
}
impl ::std::default::Default for CK_SSL3_KEY_MAT_PARAMS {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CK_SSL3_KEY_MAT_PARAMS_PTR = *mut CK_SSL3_KEY_MAT_PARAMS;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct CK_TLS_PRF_PARAMS {
    pub pSeed: CK_BYTE_PTR,
    pub ulSeedLen: CK_ULONG,
    pub pLabel: CK_BYTE_PTR,
    pub ulLabelLen: CK_ULONG,
    pub pOutput: CK_BYTE_PTR,
    pub pulOutputLen: CK_ULONG_PTR,
}
impl ::std::default::Default for CK_TLS_PRF_PARAMS {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CK_TLS_PRF_PARAMS_PTR = *mut CK_TLS_PRF_PARAMS;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct CK_TLS12_MASTER_KEY_DERIVE_PARAMS {
    pub RandomInfo: CK_SSL3_RANDOM_DATA,
    pub pVersion: CK_VERSION_PTR,
    pub prfHashMechanism: CK_MECHANISM_TYPE,
}
impl ::std::default::Default for CK_TLS12_MASTER_KEY_DERIVE_PARAMS {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CK_TLS12_MASTER_KEY_DERIVE_PARAMS_PTR =
    *mut CK_TLS12_MASTER_KEY_DERIVE_PARAMS;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct CK_TLS12_KEY_MAT_PARAMS {
    pub ulMacSizeInBits: CK_ULONG,
    pub ulKeySizeInBits: CK_ULONG,
    pub ulIVSizeInBits: CK_ULONG,
    pub bIsExport: CK_BBOOL,
    pub RandomInfo: CK_SSL3_RANDOM_DATA,
    pub pReturnedKeyMaterial: CK_SSL3_KEY_MAT_OUT_PTR,
    pub prfHashMechanism: CK_MECHANISM_TYPE,
}
impl ::std::default::Default for CK_TLS12_KEY_MAT_PARAMS {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CK_TLS12_KEY_MAT_PARAMS_PTR = *mut CK_TLS12_KEY_MAT_PARAMS;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct CK_TLS_KDF_PARAMS {
    pub prfMechanism: CK_MECHANISM_TYPE,
    pub pLabel: CK_BYTE_PTR,
    pub ulLabelLength: CK_ULONG,
    pub RandomInfo: CK_SSL3_RANDOM_DATA,
    pub pContextData: CK_BYTE_PTR,
    pub ulContextDataLength: CK_ULONG,
}
impl ::std::default::Default for CK_TLS_KDF_PARAMS {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct CK_TLS_MAC_PARAMS {
    pub prfMechanism: CK_MECHANISM_TYPE,
    pub ulMacLength: CK_ULONG,
    pub ulServerOrClient: CK_ULONG,
}
impl ::std::default::Default for CK_TLS_MAC_PARAMS {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CK_TLS_MAC_PARAMS_PTR = *mut CK_TLS_MAC_PARAMS;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct CK_WTLS_RANDOM_DATA {
    pub pClientRandom: CK_BYTE_PTR,
    pub ulClientRandomLen: CK_ULONG,
    pub pServerRandom: CK_BYTE_PTR,
    pub ulServerRandomLen: CK_ULONG,
}
impl ::std::default::Default for CK_WTLS_RANDOM_DATA {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CK_WTLS_RANDOM_DATA_PTR = *mut CK_WTLS_RANDOM_DATA;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct CK_WTLS_MASTER_KEY_DERIVE_PARAMS {
    pub DigestMechanism: CK_MECHANISM_TYPE,
    pub RandomInfo: CK_WTLS_RANDOM_DATA,
    pub pVersion: CK_BYTE_PTR,
}
impl ::std::default::Default for CK_WTLS_MASTER_KEY_DERIVE_PARAMS {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CK_WTLS_MASTER_KEY_DERIVE_PARAMS_PTR =
    *mut CK_WTLS_MASTER_KEY_DERIVE_PARAMS;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct CK_WTLS_PRF_PARAMS {
    pub DigestMechanism: CK_MECHANISM_TYPE,
    pub pSeed: CK_BYTE_PTR,
    pub ulSeedLen: CK_ULONG,
    pub pLabel: CK_BYTE_PTR,
    pub ulLabelLen: CK_ULONG,
    pub pOutput: CK_BYTE_PTR,
    pub pulOutputLen: CK_ULONG_PTR,
}
impl ::std::default::Default for CK_WTLS_PRF_PARAMS {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CK_WTLS_PRF_PARAMS_PTR = *mut CK_WTLS_PRF_PARAMS;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct CK_WTLS_KEY_MAT_OUT {
    pub hMacSecret: CK_OBJECT_HANDLE,
    pub hKey: CK_OBJECT_HANDLE,
    pub pIV: CK_BYTE_PTR,
}
impl ::std::default::Default for CK_WTLS_KEY_MAT_OUT {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CK_WTLS_KEY_MAT_OUT_PTR = *mut CK_WTLS_KEY_MAT_OUT;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct CK_WTLS_KEY_MAT_PARAMS {
    pub DigestMechanism: CK_MECHANISM_TYPE,
    pub ulMacSizeInBits: CK_ULONG,
    pub ulKeySizeInBits: CK_ULONG,
    pub ulIVSizeInBits: CK_ULONG,
    pub ulSequenceNumber: CK_ULONG,
    pub bIsExport: CK_BBOOL,
    pub RandomInfo: CK_WTLS_RANDOM_DATA,
    pub pReturnedKeyMaterial: CK_WTLS_KEY_MAT_OUT_PTR,
}
impl ::std::default::Default for CK_WTLS_KEY_MAT_PARAMS {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CK_WTLS_KEY_MAT_PARAMS_PTR = *mut CK_WTLS_KEY_MAT_PARAMS;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct CK_CMS_SIG_PARAMS {
    pub certificateHandle: CK_OBJECT_HANDLE,
    pub pSigningMechanism: CK_MECHANISM_PTR,
    pub pDigestMechanism: CK_MECHANISM_PTR,
    pub pContentType: CK_UTF8CHAR_PTR,
    pub pRequestedAttributes: CK_BYTE_PTR,
    pub ulRequestedAttributesLen: CK_ULONG,
    pub pRequiredAttributes: CK_BYTE_PTR,
    pub ulRequiredAttributesLen: CK_ULONG,
}
impl ::std::default::Default for CK_CMS_SIG_PARAMS {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CK_CMS_SIG_PARAMS_PTR = *mut CK_CMS_SIG_PARAMS;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct CK_KEY_DERIVATION_STRING_DATA {
    pub pData: CK_BYTE_PTR,
    pub ulLen: CK_ULONG,
}
impl ::std::default::Default for CK_KEY_DERIVATION_STRING_DATA {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CK_KEY_DERIVATION_STRING_DATA_PTR =
    *mut CK_KEY_DERIVATION_STRING_DATA;
pub type CK_EXTRACT_PARAMS = CK_ULONG;
pub type CK_EXTRACT_PARAMS_PTR = *mut CK_EXTRACT_PARAMS;
pub type CK_PKCS5_PBKD2_PSEUDO_RANDOM_FUNCTION_TYPE = CK_ULONG;
pub type CK_PKCS5_PBKD2_PSEUDO_RANDOM_FUNCTION_TYPE_PTR =
    *mut CK_PKCS5_PBKD2_PSEUDO_RANDOM_FUNCTION_TYPE;
pub type CK_PKCS5_PBKDF2_SALT_SOURCE_TYPE = CK_ULONG;
pub type CK_PKCS5_PBKDF2_SALT_SOURCE_TYPE_PTR =
    *mut CK_PKCS5_PBKDF2_SALT_SOURCE_TYPE;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct CK_PKCS5_PBKD2_PARAMS {
    pub saltSource: CK_PKCS5_PBKDF2_SALT_SOURCE_TYPE,
    pub pSaltSourceData: CK_VOID_PTR,
    pub ulSaltSourceDataLen: CK_ULONG,
    pub iterations: CK_ULONG,
    pub prf: CK_PKCS5_PBKD2_PSEUDO_RANDOM_FUNCTION_TYPE,
    pub pPrfData: CK_VOID_PTR,
    pub ulPrfDataLen: CK_ULONG,
    pub pPassword: CK_UTF8CHAR_PTR,
    pub ulPasswordLen: CK_ULONG_PTR,
}
impl ::std::default::Default for CK_PKCS5_PBKD2_PARAMS {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CK_PKCS5_PBKD2_PARAMS_PTR = *mut CK_PKCS5_PBKD2_PARAMS;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct CK_NSS_JPAKEPublicValue {
    pub pGX: *mut CK_BYTE,
    pub ulGXLen: CK_ULONG,
    pub pGV: *mut CK_BYTE,
    pub ulGVLen: CK_ULONG,
    pub pR: *mut CK_BYTE,
    pub ulRLen: CK_ULONG,
}
impl ::std::default::Default for CK_NSS_JPAKEPublicValue {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct CK_NSS_JPAKERound1Params {
    pub gx1: CK_NSS_JPAKEPublicValue,
    pub gx2: CK_NSS_JPAKEPublicValue,
}
impl ::std::default::Default for CK_NSS_JPAKERound1Params {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct CK_NSS_JPAKERound2Params {
    pub pSharedKey: *mut CK_BYTE,
    pub ulSharedKeyLen: CK_ULONG,
    pub gx3: CK_NSS_JPAKEPublicValue,
    pub gx4: CK_NSS_JPAKEPublicValue,
    pub A: CK_NSS_JPAKEPublicValue,
}
impl ::std::default::Default for CK_NSS_JPAKERound2Params {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct CK_NSS_JPAKEFinalParams {
    pub B: CK_NSS_JPAKEPublicValue,
}
impl ::std::default::Default for CK_NSS_JPAKEFinalParams {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct CK_NSS_MAC_CONSTANT_TIME_PARAMS {
    pub macAlg: CK_MECHANISM_TYPE,
    pub ulBodyTotalLen: CK_ULONG,
    pub pHeader: *mut CK_BYTE,
    pub ulHeaderLen: CK_ULONG,
}
impl ::std::default::Default for CK_NSS_MAC_CONSTANT_TIME_PARAMS {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct CK_NSS_AEAD_PARAMS {
    pub pNonce: CK_BYTE_PTR,
    pub ulNonceLen: CK_ULONG,
    pub pAAD: CK_BYTE_PTR,
    pub ulAADLen: CK_ULONG,
    pub ulTagLen: CK_ULONG,
}
impl ::std::default::Default for CK_NSS_AEAD_PARAMS {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct CK_NSS_HKDFParams {
    pub bExtract: CK_BBOOL,
    pub pSalt: CK_BYTE_PTR,
    pub ulSaltLen: CK_ULONG,
    pub bExpand: CK_BBOOL,
    pub pInfo: CK_BYTE_PTR,
    pub ulInfoLen: CK_ULONG,
}
impl ::std::default::Default for CK_NSS_HKDFParams {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct CK_NSS_TLS_EXTENDED_MASTER_KEY_DERIVE_PARAMS {
    pub prfHashMechanism: CK_MECHANISM_TYPE,
    pub pSessionHash: CK_BYTE_PTR,
    pub ulSessionHashLen: CK_ULONG,
    pub pVersion: CK_VERSION_PTR,
}
impl ::std::default::Default for CK_NSS_TLS_EXTENDED_MASTER_KEY_DERIVE_PARAMS
 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CK_TRUST = CK_ULONG;
pub type __CKT_NSS_UNTRUSTED = CK_TRUST;
pub type __CKT_NSS_VALID = CK_TRUST;
pub type __CKT_NSS_MUST_VERIFY = CK_TRUST;
pub type SECMODModuleDBFunc =
    ::std::option::Option<unsafe extern "C" fn(function:
                                                   ::std::os::raw::c_ulong,
                                               parameters:
                                                   *mut ::std::os::raw::c_char,
                                               moduleSpec:
                                                   *mut ::std::os::raw::c_void)
                              -> *mut *mut ::std::os::raw::c_char>;
pub type CK_C_Initialize =
    ::std::option::Option<extern "C" fn(pInitArgs: CK_VOID_PTR) -> CK_RV>;
pub type CK_C_Finalize =
    ::std::option::Option<extern "C" fn(pReserved: CK_VOID_PTR) -> CK_RV>;
pub type CK_C_GetInfo =
    ::std::option::Option<extern "C" fn(pInfo: CK_INFO_PTR) -> CK_RV>;
pub type CK_C_GetFunctionList =
    ::std::option::Option<extern "C" fn(ppFunctionList:
                                            CK_FUNCTION_LIST_PTR_PTR)
                              -> CK_RV>;
pub type CK_C_GetSlotList =
    ::std::option::Option<extern "C" fn(tokenPresent: CK_BBOOL,
                                        pSlotList: CK_SLOT_ID_PTR,
                                        pulCount: CK_ULONG_PTR) -> CK_RV>;
pub type CK_C_GetSlotInfo =
    ::std::option::Option<extern "C" fn(slotID: CK_SLOT_ID,
                                        pInfo: CK_SLOT_INFO_PTR) -> CK_RV>;
pub type CK_C_GetTokenInfo =
    ::std::option::Option<extern "C" fn(slotID: CK_SLOT_ID,
                                        pInfo: CK_TOKEN_INFO_PTR) -> CK_RV>;
pub type CK_C_GetMechanismList =
    ::std::option::Option<extern "C" fn(slotID: CK_SLOT_ID,
                                        pMechanismList: CK_MECHANISM_TYPE_PTR,
                                        pulCount: CK_ULONG_PTR) -> CK_RV>;
pub type CK_C_GetMechanismInfo =
    ::std::option::Option<extern "C" fn(slotID: CK_SLOT_ID,
                                        type_: CK_MECHANISM_TYPE,
                                        pInfo: CK_MECHANISM_INFO_PTR)
                              -> CK_RV>;
pub type CK_C_InitToken =
    ::std::option::Option<extern "C" fn(slotID: CK_SLOT_ID,
                                        pPin: CK_UTF8CHAR_PTR,
                                        ulPinLen: CK_ULONG,
                                        pLabel: CK_UTF8CHAR_PTR) -> CK_RV>;
pub type CK_C_InitPIN =
    ::std::option::Option<extern "C" fn(hSession: CK_SESSION_HANDLE,
                                        pPin: CK_UTF8CHAR_PTR,
                                        ulPinLen: CK_ULONG) -> CK_RV>;
pub type CK_C_SetPIN =
    ::std::option::Option<extern "C" fn(hSession: CK_SESSION_HANDLE,
                                        pOldPin: CK_UTF8CHAR_PTR,
                                        ulOldLen: CK_ULONG,
                                        pNewPin: CK_UTF8CHAR_PTR,
                                        ulNewLen: CK_ULONG) -> CK_RV>;
pub type CK_C_OpenSession =
    ::std::option::Option<extern "C" fn(slotID: CK_SLOT_ID, flags: CK_FLAGS,
                                        pApplication: CK_VOID_PTR,
                                        Notify: CK_NOTIFY,
                                        phSession: CK_SESSION_HANDLE_PTR)
                              -> CK_RV>;
pub type CK_C_CloseSession =
    ::std::option::Option<extern "C" fn(hSession: CK_SESSION_HANDLE)
                              -> CK_RV>;
pub type CK_C_CloseAllSessions =
    ::std::option::Option<extern "C" fn(slotID: CK_SLOT_ID) -> CK_RV>;
pub type CK_C_GetSessionInfo =
    ::std::option::Option<extern "C" fn(hSession: CK_SESSION_HANDLE,
                                        pInfo: CK_SESSION_INFO_PTR) -> CK_RV>;
pub type CK_C_GetOperationState =
    ::std::option::Option<extern "C" fn(hSession: CK_SESSION_HANDLE,
                                        pOperationState: CK_BYTE_PTR,
                                        pulOperationStateLen: CK_ULONG_PTR)
                              -> CK_RV>;
pub type CK_C_SetOperationState =
    ::std::option::Option<extern "C" fn(hSession: CK_SESSION_HANDLE,
                                        pOperationState: CK_BYTE_PTR,
                                        ulOperationStateLen: CK_ULONG,
                                        hEncryptionKey: CK_OBJECT_HANDLE,
                                        hAuthenticationKey: CK_OBJECT_HANDLE)
                              -> CK_RV>;
pub type CK_C_Login =
    ::std::option::Option<extern "C" fn(hSession: CK_SESSION_HANDLE,
                                        userType: CK_USER_TYPE,
                                        pPin: CK_UTF8CHAR_PTR,
                                        ulPinLen: CK_ULONG) -> CK_RV>;
pub type CK_C_Logout =
    ::std::option::Option<extern "C" fn(hSession: CK_SESSION_HANDLE)
                              -> CK_RV>;
pub type CK_C_CreateObject =
    ::std::option::Option<extern "C" fn(hSession: CK_SESSION_HANDLE,
                                        pTemplate: CK_ATTRIBUTE_PTR,
                                        ulCount: CK_ULONG,
                                        phObject: CK_OBJECT_HANDLE_PTR)
                              -> CK_RV>;
pub type CK_C_CopyObject =
    ::std::option::Option<extern "C" fn(hSession: CK_SESSION_HANDLE,
                                        hObject: CK_OBJECT_HANDLE,
                                        pTemplate: CK_ATTRIBUTE_PTR,
                                        ulCount: CK_ULONG,
                                        phNewObject: CK_OBJECT_HANDLE_PTR)
                              -> CK_RV>;
pub type CK_C_DestroyObject =
    ::std::option::Option<extern "C" fn(hSession: CK_SESSION_HANDLE,
                                        hObject: CK_OBJECT_HANDLE) -> CK_RV>;
pub type CK_C_GetObjectSize =
    ::std::option::Option<extern "C" fn(hSession: CK_SESSION_HANDLE,
                                        hObject: CK_OBJECT_HANDLE,
                                        pulSize: CK_ULONG_PTR) -> CK_RV>;
pub type CK_C_GetAttributeValue =
    ::std::option::Option<extern "C" fn(hSession: CK_SESSION_HANDLE,
                                        hObject: CK_OBJECT_HANDLE,
                                        pTemplate: CK_ATTRIBUTE_PTR,
                                        ulCount: CK_ULONG) -> CK_RV>;
pub type CK_C_SetAttributeValue =
    ::std::option::Option<extern "C" fn(hSession: CK_SESSION_HANDLE,
                                        hObject: CK_OBJECT_HANDLE,
                                        pTemplate: CK_ATTRIBUTE_PTR,
                                        ulCount: CK_ULONG) -> CK_RV>;
pub type CK_C_FindObjectsInit =
    ::std::option::Option<extern "C" fn(hSession: CK_SESSION_HANDLE,
                                        pTemplate: CK_ATTRIBUTE_PTR,
                                        ulCount: CK_ULONG) -> CK_RV>;
pub type CK_C_FindObjects =
    ::std::option::Option<extern "C" fn(hSession: CK_SESSION_HANDLE,
                                        phObject: CK_OBJECT_HANDLE_PTR,
                                        ulMaxObjectCount: CK_ULONG,
                                        pulObjectCount: CK_ULONG_PTR)
                              -> CK_RV>;
pub type CK_C_FindObjectsFinal =
    ::std::option::Option<extern "C" fn(hSession: CK_SESSION_HANDLE)
                              -> CK_RV>;
pub type CK_C_EncryptInit =
    ::std::option::Option<extern "C" fn(hSession: CK_SESSION_HANDLE,
                                        pMechanism: CK_MECHANISM_PTR,
                                        hKey: CK_OBJECT_HANDLE) -> CK_RV>;
pub type CK_C_Encrypt =
    ::std::option::Option<extern "C" fn(hSession: CK_SESSION_HANDLE,
                                        pData: CK_BYTE_PTR,
                                        ulDataLen: CK_ULONG,
                                        pEncryptedData: CK_BYTE_PTR,
                                        pulEncryptedDataLen: CK_ULONG_PTR)
                              -> CK_RV>;
pub type CK_C_EncryptUpdate =
    ::std::option::Option<extern "C" fn(hSession: CK_SESSION_HANDLE,
                                        pPart: CK_BYTE_PTR,
                                        ulPartLen: CK_ULONG,
                                        pEncryptedPart: CK_BYTE_PTR,
                                        pulEncryptedPartLen: CK_ULONG_PTR)
                              -> CK_RV>;
pub type CK_C_EncryptFinal =
    ::std::option::Option<extern "C" fn(hSession: CK_SESSION_HANDLE,
                                        pLastEncryptedPart: CK_BYTE_PTR,
                                        pulLastEncryptedPartLen: CK_ULONG_PTR)
                              -> CK_RV>;
pub type CK_C_DecryptInit =
    ::std::option::Option<extern "C" fn(hSession: CK_SESSION_HANDLE,
                                        pMechanism: CK_MECHANISM_PTR,
                                        hKey: CK_OBJECT_HANDLE) -> CK_RV>;
pub type CK_C_Decrypt =
    ::std::option::Option<extern "C" fn(hSession: CK_SESSION_HANDLE,
                                        pEncryptedData: CK_BYTE_PTR,
                                        ulEncryptedDataLen: CK_ULONG,
                                        pData: CK_BYTE_PTR,
                                        pulDataLen: CK_ULONG_PTR) -> CK_RV>;
pub type CK_C_DecryptUpdate =
    ::std::option::Option<extern "C" fn(hSession: CK_SESSION_HANDLE,
                                        pEncryptedPart: CK_BYTE_PTR,
                                        ulEncryptedPartLen: CK_ULONG,
                                        pPart: CK_BYTE_PTR,
                                        pulPartLen: CK_ULONG_PTR) -> CK_RV>;
pub type CK_C_DecryptFinal =
    ::std::option::Option<extern "C" fn(hSession: CK_SESSION_HANDLE,
                                        pLastPart: CK_BYTE_PTR,
                                        pulLastPartLen: CK_ULONG_PTR)
                              -> CK_RV>;
pub type CK_C_DigestInit =
    ::std::option::Option<extern "C" fn(hSession: CK_SESSION_HANDLE,
                                        pMechanism: CK_MECHANISM_PTR)
                              -> CK_RV>;
pub type CK_C_Digest =
    ::std::option::Option<extern "C" fn(hSession: CK_SESSION_HANDLE,
                                        pData: CK_BYTE_PTR,
                                        ulDataLen: CK_ULONG,
                                        pDigest: CK_BYTE_PTR,
                                        pulDigestLen: CK_ULONG_PTR) -> CK_RV>;
pub type CK_C_DigestUpdate =
    ::std::option::Option<extern "C" fn(hSession: CK_SESSION_HANDLE,
                                        pPart: CK_BYTE_PTR,
                                        ulPartLen: CK_ULONG) -> CK_RV>;
pub type CK_C_DigestKey =
    ::std::option::Option<extern "C" fn(hSession: CK_SESSION_HANDLE,
                                        hKey: CK_OBJECT_HANDLE) -> CK_RV>;
pub type CK_C_DigestFinal =
    ::std::option::Option<extern "C" fn(hSession: CK_SESSION_HANDLE,
                                        pDigest: CK_BYTE_PTR,
                                        pulDigestLen: CK_ULONG_PTR) -> CK_RV>;
pub type CK_C_SignInit =
    ::std::option::Option<extern "C" fn(hSession: CK_SESSION_HANDLE,
                                        pMechanism: CK_MECHANISM_PTR,
                                        hKey: CK_OBJECT_HANDLE) -> CK_RV>;
pub type CK_C_Sign =
    ::std::option::Option<extern "C" fn(hSession: CK_SESSION_HANDLE,
                                        pData: CK_BYTE_PTR,
                                        ulDataLen: CK_ULONG,
                                        pSignature: CK_BYTE_PTR,
                                        pulSignatureLen: CK_ULONG_PTR)
                              -> CK_RV>;
pub type CK_C_SignUpdate =
    ::std::option::Option<extern "C" fn(hSession: CK_SESSION_HANDLE,
                                        pPart: CK_BYTE_PTR,
                                        ulPartLen: CK_ULONG) -> CK_RV>;
pub type CK_C_SignFinal =
    ::std::option::Option<extern "C" fn(hSession: CK_SESSION_HANDLE,
                                        pSignature: CK_BYTE_PTR,
                                        pulSignatureLen: CK_ULONG_PTR)
                              -> CK_RV>;
pub type CK_C_SignRecoverInit =
    ::std::option::Option<extern "C" fn(hSession: CK_SESSION_HANDLE,
                                        pMechanism: CK_MECHANISM_PTR,
                                        hKey: CK_OBJECT_HANDLE) -> CK_RV>;
pub type CK_C_SignRecover =
    ::std::option::Option<extern "C" fn(hSession: CK_SESSION_HANDLE,
                                        pData: CK_BYTE_PTR,
                                        ulDataLen: CK_ULONG,
                                        pSignature: CK_BYTE_PTR,
                                        pulSignatureLen: CK_ULONG_PTR)
                              -> CK_RV>;
pub type CK_C_VerifyInit =
    ::std::option::Option<extern "C" fn(hSession: CK_SESSION_HANDLE,
                                        pMechanism: CK_MECHANISM_PTR,
                                        hKey: CK_OBJECT_HANDLE) -> CK_RV>;
pub type CK_C_Verify =
    ::std::option::Option<extern "C" fn(hSession: CK_SESSION_HANDLE,
                                        pData: CK_BYTE_PTR,
                                        ulDataLen: CK_ULONG,
                                        pSignature: CK_BYTE_PTR,
                                        ulSignatureLen: CK_ULONG) -> CK_RV>;
pub type CK_C_VerifyUpdate =
    ::std::option::Option<extern "C" fn(hSession: CK_SESSION_HANDLE,
                                        pPart: CK_BYTE_PTR,
                                        ulPartLen: CK_ULONG) -> CK_RV>;
pub type CK_C_VerifyFinal =
    ::std::option::Option<extern "C" fn(hSession: CK_SESSION_HANDLE,
                                        pSignature: CK_BYTE_PTR,
                                        ulSignatureLen: CK_ULONG) -> CK_RV>;
pub type CK_C_VerifyRecoverInit =
    ::std::option::Option<extern "C" fn(hSession: CK_SESSION_HANDLE,
                                        pMechanism: CK_MECHANISM_PTR,
                                        hKey: CK_OBJECT_HANDLE) -> CK_RV>;
pub type CK_C_VerifyRecover =
    ::std::option::Option<extern "C" fn(hSession: CK_SESSION_HANDLE,
                                        pSignature: CK_BYTE_PTR,
                                        ulSignatureLen: CK_ULONG,
                                        pData: CK_BYTE_PTR,
                                        pulDataLen: CK_ULONG_PTR) -> CK_RV>;
pub type CK_C_DigestEncryptUpdate =
    ::std::option::Option<extern "C" fn(hSession: CK_SESSION_HANDLE,
                                        pPart: CK_BYTE_PTR,
                                        ulPartLen: CK_ULONG,
                                        pEncryptedPart: CK_BYTE_PTR,
                                        pulEncryptedPartLen: CK_ULONG_PTR)
                              -> CK_RV>;
pub type CK_C_DecryptDigestUpdate =
    ::std::option::Option<extern "C" fn(hSession: CK_SESSION_HANDLE,
                                        pEncryptedPart: CK_BYTE_PTR,
                                        ulEncryptedPartLen: CK_ULONG,
                                        pPart: CK_BYTE_PTR,
                                        pulPartLen: CK_ULONG_PTR) -> CK_RV>;
pub type CK_C_SignEncryptUpdate =
    ::std::option::Option<extern "C" fn(hSession: CK_SESSION_HANDLE,
                                        pPart: CK_BYTE_PTR,
                                        ulPartLen: CK_ULONG,
                                        pEncryptedPart: CK_BYTE_PTR,
                                        pulEncryptedPartLen: CK_ULONG_PTR)
                              -> CK_RV>;
pub type CK_C_DecryptVerifyUpdate =
    ::std::option::Option<extern "C" fn(hSession: CK_SESSION_HANDLE,
                                        pEncryptedPart: CK_BYTE_PTR,
                                        ulEncryptedPartLen: CK_ULONG,
                                        pPart: CK_BYTE_PTR,
                                        pulPartLen: CK_ULONG_PTR) -> CK_RV>;
pub type CK_C_GenerateKey =
    ::std::option::Option<extern "C" fn(hSession: CK_SESSION_HANDLE,
                                        pMechanism: CK_MECHANISM_PTR,
                                        pTemplate: CK_ATTRIBUTE_PTR,
                                        ulCount: CK_ULONG,
                                        phKey: CK_OBJECT_HANDLE_PTR)
                              -> CK_RV>;
pub type CK_C_GenerateKeyPair =
    ::std::option::Option<extern "C" fn(hSession: CK_SESSION_HANDLE,
                                        pMechanism: CK_MECHANISM_PTR,
                                        pPublicKeyTemplate: CK_ATTRIBUTE_PTR,
                                        ulPublicKeyAttributeCount: CK_ULONG,
                                        pPrivateKeyTemplate: CK_ATTRIBUTE_PTR,
                                        ulPrivateKeyAttributeCount: CK_ULONG,
                                        phPublicKey: CK_OBJECT_HANDLE_PTR,
                                        phPrivateKey: CK_OBJECT_HANDLE_PTR)
                              -> CK_RV>;
pub type CK_C_WrapKey =
    ::std::option::Option<extern "C" fn(hSession: CK_SESSION_HANDLE,
                                        pMechanism: CK_MECHANISM_PTR,
                                        hWrappingKey: CK_OBJECT_HANDLE,
                                        hKey: CK_OBJECT_HANDLE,
                                        pWrappedKey: CK_BYTE_PTR,
                                        pulWrappedKeyLen: CK_ULONG_PTR)
                              -> CK_RV>;
pub type CK_C_UnwrapKey =
    ::std::option::Option<extern "C" fn(hSession: CK_SESSION_HANDLE,
                                        pMechanism: CK_MECHANISM_PTR,
                                        hUnwrappingKey: CK_OBJECT_HANDLE,
                                        pWrappedKey: CK_BYTE_PTR,
                                        ulWrappedKeyLen: CK_ULONG,
                                        pTemplate: CK_ATTRIBUTE_PTR,
                                        ulAttributeCount: CK_ULONG,
                                        phKey: CK_OBJECT_HANDLE_PTR)
                              -> CK_RV>;
pub type CK_C_DeriveKey =
    ::std::option::Option<extern "C" fn(hSession: CK_SESSION_HANDLE,
                                        pMechanism: CK_MECHANISM_PTR,
                                        hBaseKey: CK_OBJECT_HANDLE,
                                        pTemplate: CK_ATTRIBUTE_PTR,
                                        ulAttributeCount: CK_ULONG,
                                        phKey: CK_OBJECT_HANDLE_PTR)
                              -> CK_RV>;
pub type CK_C_SeedRandom =
    ::std::option::Option<extern "C" fn(hSession: CK_SESSION_HANDLE,
                                        pSeed: CK_BYTE_PTR,
                                        ulSeedLen: CK_ULONG) -> CK_RV>;
pub type CK_C_GenerateRandom =
    ::std::option::Option<extern "C" fn(hSession: CK_SESSION_HANDLE,
                                        RandomData: CK_BYTE_PTR,
                                        ulRandomLen: CK_ULONG) -> CK_RV>;
pub type CK_C_GetFunctionStatus =
    ::std::option::Option<extern "C" fn(hSession: CK_SESSION_HANDLE)
                              -> CK_RV>;
pub type CK_C_CancelFunction =
    ::std::option::Option<extern "C" fn(hSession: CK_SESSION_HANDLE)
                              -> CK_RV>;
pub type CK_C_WaitForSlotEvent =
    ::std::option::Option<extern "C" fn(flags: CK_FLAGS,
                                        pSlot: CK_SLOT_ID_PTR,
                                        pRserved: CK_VOID_PTR) -> CK_RV>;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct CK_FUNCTION_LIST {
    pub version: CK_VERSION,
    pub C_Initialize: CK_C_Initialize,
    pub C_Finalize: CK_C_Finalize,
    pub C_GetInfo: CK_C_GetInfo,
    pub C_GetFunctionList: CK_C_GetFunctionList,
    pub C_GetSlotList: CK_C_GetSlotList,
    pub C_GetSlotInfo: CK_C_GetSlotInfo,
    pub C_GetTokenInfo: CK_C_GetTokenInfo,
    pub C_GetMechanismList: CK_C_GetMechanismList,
    pub C_GetMechanismInfo: CK_C_GetMechanismInfo,
    pub C_InitToken: CK_C_InitToken,
    pub C_InitPIN: CK_C_InitPIN,
    pub C_SetPIN: CK_C_SetPIN,
    pub C_OpenSession: CK_C_OpenSession,
    pub C_CloseSession: CK_C_CloseSession,
    pub C_CloseAllSessions: CK_C_CloseAllSessions,
    pub C_GetSessionInfo: CK_C_GetSessionInfo,
    pub C_GetOperationState: CK_C_GetOperationState,
    pub C_SetOperationState: CK_C_SetOperationState,
    pub C_Login: CK_C_Login,
    pub C_Logout: CK_C_Logout,
    pub C_CreateObject: CK_C_CreateObject,
    pub C_CopyObject: CK_C_CopyObject,
    pub C_DestroyObject: CK_C_DestroyObject,
    pub C_GetObjectSize: CK_C_GetObjectSize,
    pub C_GetAttributeValue: CK_C_GetAttributeValue,
    pub C_SetAttributeValue: CK_C_SetAttributeValue,
    pub C_FindObjectsInit: CK_C_FindObjectsInit,
    pub C_FindObjects: CK_C_FindObjects,
    pub C_FindObjectsFinal: CK_C_FindObjectsFinal,
    pub C_EncryptInit: CK_C_EncryptInit,
    pub C_Encrypt: CK_C_Encrypt,
    pub C_EncryptUpdate: CK_C_EncryptUpdate,
    pub C_EncryptFinal: CK_C_EncryptFinal,
    pub C_DecryptInit: CK_C_DecryptInit,
    pub C_Decrypt: CK_C_Decrypt,
    pub C_DecryptUpdate: CK_C_DecryptUpdate,
    pub C_DecryptFinal: CK_C_DecryptFinal,
    pub C_DigestInit: CK_C_DigestInit,
    pub C_Digest: CK_C_Digest,
    pub C_DigestUpdate: CK_C_DigestUpdate,
    pub C_DigestKey: CK_C_DigestKey,
    pub C_DigestFinal: CK_C_DigestFinal,
    pub C_SignInit: CK_C_SignInit,
    pub C_Sign: CK_C_Sign,
    pub C_SignUpdate: CK_C_SignUpdate,
    pub C_SignFinal: CK_C_SignFinal,
    pub C_SignRecoverInit: CK_C_SignRecoverInit,
    pub C_SignRecover: CK_C_SignRecover,
    pub C_VerifyInit: CK_C_VerifyInit,
    pub C_Verify: CK_C_Verify,
    pub C_VerifyUpdate: CK_C_VerifyUpdate,
    pub C_VerifyFinal: CK_C_VerifyFinal,
    pub C_VerifyRecoverInit: CK_C_VerifyRecoverInit,
    pub C_VerifyRecover: CK_C_VerifyRecover,
    pub C_DigestEncryptUpdate: CK_C_DigestEncryptUpdate,
    pub C_DecryptDigestUpdate: CK_C_DecryptDigestUpdate,
    pub C_SignEncryptUpdate: CK_C_SignEncryptUpdate,
    pub C_DecryptVerifyUpdate: CK_C_DecryptVerifyUpdate,
    pub C_GenerateKey: CK_C_GenerateKey,
    pub C_GenerateKeyPair: CK_C_GenerateKeyPair,
    pub C_WrapKey: CK_C_WrapKey,
    pub C_UnwrapKey: CK_C_UnwrapKey,
    pub C_DeriveKey: CK_C_DeriveKey,
    pub C_SeedRandom: CK_C_SeedRandom,
    pub C_GenerateRandom: CK_C_GenerateRandom,
    pub C_GetFunctionStatus: CK_C_GetFunctionStatus,
    pub C_CancelFunction: CK_C_CancelFunction,
    pub C_WaitForSlotEvent: CK_C_WaitForSlotEvent,
}
impl ::std::default::Default for CK_FUNCTION_LIST {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
extern "C" {
    pub fn select(__nfds: ::std::os::raw::c_int, __readfds: *mut fd_set,
                  __writefds: *mut fd_set, __exceptfds: *mut fd_set,
                  __timeout: *mut timeval) -> ::std::os::raw::c_int;
    pub fn pselect(__nfds: ::std::os::raw::c_int, __readfds: *mut fd_set,
                   __writefds: *mut fd_set, __exceptfds: *mut fd_set,
                   __timeout: *const timespec, __sigmask: *const __sigset_t)
     -> ::std::os::raw::c_int;
    pub fn gnu_dev_major(__dev: ::std::os::raw::c_ulonglong)
     -> ::std::os::raw::c_uint;
    pub fn gnu_dev_minor(__dev: ::std::os::raw::c_ulonglong)
     -> ::std::os::raw::c_uint;
    pub fn gnu_dev_makedev(__major: ::std::os::raw::c_uint,
                           __minor: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_ulonglong;
    pub fn C_Initialize(pInitArgs: CK_VOID_PTR) -> CK_RV;
    pub fn C_Finalize(pReserved: CK_VOID_PTR) -> CK_RV;
    pub fn C_GetInfo(pInfo: CK_INFO_PTR) -> CK_RV;
    pub fn C_GetFunctionList(ppFunctionList: CK_FUNCTION_LIST_PTR_PTR)
     -> CK_RV;
    pub fn C_GetSlotList(tokenPresent: CK_BBOOL, pSlotList: CK_SLOT_ID_PTR,
                         pulCount: CK_ULONG_PTR) -> CK_RV;
    pub fn C_GetSlotInfo(slotID: CK_SLOT_ID, pInfo: CK_SLOT_INFO_PTR)
     -> CK_RV;
    pub fn C_GetTokenInfo(slotID: CK_SLOT_ID, pInfo: CK_TOKEN_INFO_PTR)
     -> CK_RV;
    pub fn C_GetMechanismList(slotID: CK_SLOT_ID,
                              pMechanismList: CK_MECHANISM_TYPE_PTR,
                              pulCount: CK_ULONG_PTR) -> CK_RV;
    pub fn C_GetMechanismInfo(slotID: CK_SLOT_ID, type_: CK_MECHANISM_TYPE,
                              pInfo: CK_MECHANISM_INFO_PTR) -> CK_RV;
    pub fn C_InitToken(slotID: CK_SLOT_ID, pPin: CK_UTF8CHAR_PTR,
                       ulPinLen: CK_ULONG, pLabel: CK_UTF8CHAR_PTR) -> CK_RV;
    pub fn C_InitPIN(hSession: CK_SESSION_HANDLE, pPin: CK_UTF8CHAR_PTR,
                     ulPinLen: CK_ULONG) -> CK_RV;
    pub fn C_SetPIN(hSession: CK_SESSION_HANDLE, pOldPin: CK_UTF8CHAR_PTR,
                    ulOldLen: CK_ULONG, pNewPin: CK_UTF8CHAR_PTR,
                    ulNewLen: CK_ULONG) -> CK_RV;
    pub fn C_OpenSession(slotID: CK_SLOT_ID, flags: CK_FLAGS,
                         pApplication: CK_VOID_PTR, Notify: CK_NOTIFY,
                         phSession: CK_SESSION_HANDLE_PTR) -> CK_RV;
    pub fn C_CloseSession(hSession: CK_SESSION_HANDLE) -> CK_RV;
    pub fn C_CloseAllSessions(slotID: CK_SLOT_ID) -> CK_RV;
    pub fn C_GetSessionInfo(hSession: CK_SESSION_HANDLE,
                            pInfo: CK_SESSION_INFO_PTR) -> CK_RV;
    pub fn C_GetOperationState(hSession: CK_SESSION_HANDLE,
                               pOperationState: CK_BYTE_PTR,
                               pulOperationStateLen: CK_ULONG_PTR) -> CK_RV;
    pub fn C_SetOperationState(hSession: CK_SESSION_HANDLE,
                               pOperationState: CK_BYTE_PTR,
                               ulOperationStateLen: CK_ULONG,
                               hEncryptionKey: CK_OBJECT_HANDLE,
                               hAuthenticationKey: CK_OBJECT_HANDLE) -> CK_RV;
    pub fn C_Login(hSession: CK_SESSION_HANDLE, userType: CK_USER_TYPE,
                   pPin: CK_UTF8CHAR_PTR, ulPinLen: CK_ULONG) -> CK_RV;
    pub fn C_Logout(hSession: CK_SESSION_HANDLE) -> CK_RV;
    pub fn C_CreateObject(hSession: CK_SESSION_HANDLE,
                          pTemplate: CK_ATTRIBUTE_PTR, ulCount: CK_ULONG,
                          phObject: CK_OBJECT_HANDLE_PTR) -> CK_RV;
    pub fn C_CopyObject(hSession: CK_SESSION_HANDLE,
                        hObject: CK_OBJECT_HANDLE,
                        pTemplate: CK_ATTRIBUTE_PTR, ulCount: CK_ULONG,
                        phNewObject: CK_OBJECT_HANDLE_PTR) -> CK_RV;
    pub fn C_DestroyObject(hSession: CK_SESSION_HANDLE,
                           hObject: CK_OBJECT_HANDLE) -> CK_RV;
    pub fn C_GetObjectSize(hSession: CK_SESSION_HANDLE,
                           hObject: CK_OBJECT_HANDLE, pulSize: CK_ULONG_PTR)
     -> CK_RV;
    pub fn C_GetAttributeValue(hSession: CK_SESSION_HANDLE,
                               hObject: CK_OBJECT_HANDLE,
                               pTemplate: CK_ATTRIBUTE_PTR, ulCount: CK_ULONG)
     -> CK_RV;
    pub fn C_SetAttributeValue(hSession: CK_SESSION_HANDLE,
                               hObject: CK_OBJECT_HANDLE,
                               pTemplate: CK_ATTRIBUTE_PTR, ulCount: CK_ULONG)
     -> CK_RV;
    pub fn C_FindObjectsInit(hSession: CK_SESSION_HANDLE,
                             pTemplate: CK_ATTRIBUTE_PTR, ulCount: CK_ULONG)
     -> CK_RV;
    pub fn C_FindObjects(hSession: CK_SESSION_HANDLE,
                         phObject: CK_OBJECT_HANDLE_PTR,
                         ulMaxObjectCount: CK_ULONG,
                         pulObjectCount: CK_ULONG_PTR) -> CK_RV;
    pub fn C_FindObjectsFinal(hSession: CK_SESSION_HANDLE) -> CK_RV;
    pub fn C_EncryptInit(hSession: CK_SESSION_HANDLE,
                         pMechanism: CK_MECHANISM_PTR, hKey: CK_OBJECT_HANDLE)
     -> CK_RV;
    pub fn C_Encrypt(hSession: CK_SESSION_HANDLE, pData: CK_BYTE_PTR,
                     ulDataLen: CK_ULONG, pEncryptedData: CK_BYTE_PTR,
                     pulEncryptedDataLen: CK_ULONG_PTR) -> CK_RV;
    pub fn C_EncryptUpdate(hSession: CK_SESSION_HANDLE, pPart: CK_BYTE_PTR,
                           ulPartLen: CK_ULONG, pEncryptedPart: CK_BYTE_PTR,
                           pulEncryptedPartLen: CK_ULONG_PTR) -> CK_RV;
    pub fn C_EncryptFinal(hSession: CK_SESSION_HANDLE,
                          pLastEncryptedPart: CK_BYTE_PTR,
                          pulLastEncryptedPartLen: CK_ULONG_PTR) -> CK_RV;
    pub fn C_DecryptInit(hSession: CK_SESSION_HANDLE,
                         pMechanism: CK_MECHANISM_PTR, hKey: CK_OBJECT_HANDLE)
     -> CK_RV;
    pub fn C_Decrypt(hSession: CK_SESSION_HANDLE, pEncryptedData: CK_BYTE_PTR,
                     ulEncryptedDataLen: CK_ULONG, pData: CK_BYTE_PTR,
                     pulDataLen: CK_ULONG_PTR) -> CK_RV;
    pub fn C_DecryptUpdate(hSession: CK_SESSION_HANDLE,
                           pEncryptedPart: CK_BYTE_PTR,
                           ulEncryptedPartLen: CK_ULONG, pPart: CK_BYTE_PTR,
                           pulPartLen: CK_ULONG_PTR) -> CK_RV;
    pub fn C_DecryptFinal(hSession: CK_SESSION_HANDLE, pLastPart: CK_BYTE_PTR,
                          pulLastPartLen: CK_ULONG_PTR) -> CK_RV;
    pub fn C_DigestInit(hSession: CK_SESSION_HANDLE,
                        pMechanism: CK_MECHANISM_PTR) -> CK_RV;
    pub fn C_Digest(hSession: CK_SESSION_HANDLE, pData: CK_BYTE_PTR,
                    ulDataLen: CK_ULONG, pDigest: CK_BYTE_PTR,
                    pulDigestLen: CK_ULONG_PTR) -> CK_RV;
    pub fn C_DigestUpdate(hSession: CK_SESSION_HANDLE, pPart: CK_BYTE_PTR,
                          ulPartLen: CK_ULONG) -> CK_RV;
    pub fn C_DigestKey(hSession: CK_SESSION_HANDLE, hKey: CK_OBJECT_HANDLE)
     -> CK_RV;
    pub fn C_DigestFinal(hSession: CK_SESSION_HANDLE, pDigest: CK_BYTE_PTR,
                         pulDigestLen: CK_ULONG_PTR) -> CK_RV;
    pub fn C_SignInit(hSession: CK_SESSION_HANDLE,
                      pMechanism: CK_MECHANISM_PTR, hKey: CK_OBJECT_HANDLE)
     -> CK_RV;
    pub fn C_Sign(hSession: CK_SESSION_HANDLE, pData: CK_BYTE_PTR,
                  ulDataLen: CK_ULONG, pSignature: CK_BYTE_PTR,
                  pulSignatureLen: CK_ULONG_PTR) -> CK_RV;
    pub fn C_SignUpdate(hSession: CK_SESSION_HANDLE, pPart: CK_BYTE_PTR,
                        ulPartLen: CK_ULONG) -> CK_RV;
    pub fn C_SignFinal(hSession: CK_SESSION_HANDLE, pSignature: CK_BYTE_PTR,
                       pulSignatureLen: CK_ULONG_PTR) -> CK_RV;
    pub fn C_SignRecoverInit(hSession: CK_SESSION_HANDLE,
                             pMechanism: CK_MECHANISM_PTR,
                             hKey: CK_OBJECT_HANDLE) -> CK_RV;
    pub fn C_SignRecover(hSession: CK_SESSION_HANDLE, pData: CK_BYTE_PTR,
                         ulDataLen: CK_ULONG, pSignature: CK_BYTE_PTR,
                         pulSignatureLen: CK_ULONG_PTR) -> CK_RV;
    pub fn C_VerifyInit(hSession: CK_SESSION_HANDLE,
                        pMechanism: CK_MECHANISM_PTR, hKey: CK_OBJECT_HANDLE)
     -> CK_RV;
    pub fn C_Verify(hSession: CK_SESSION_HANDLE, pData: CK_BYTE_PTR,
                    ulDataLen: CK_ULONG, pSignature: CK_BYTE_PTR,
                    ulSignatureLen: CK_ULONG) -> CK_RV;
    pub fn C_VerifyUpdate(hSession: CK_SESSION_HANDLE, pPart: CK_BYTE_PTR,
                          ulPartLen: CK_ULONG) -> CK_RV;
    pub fn C_VerifyFinal(hSession: CK_SESSION_HANDLE, pSignature: CK_BYTE_PTR,
                         ulSignatureLen: CK_ULONG) -> CK_RV;
    pub fn C_VerifyRecoverInit(hSession: CK_SESSION_HANDLE,
                               pMechanism: CK_MECHANISM_PTR,
                               hKey: CK_OBJECT_HANDLE) -> CK_RV;
    pub fn C_VerifyRecover(hSession: CK_SESSION_HANDLE,
                           pSignature: CK_BYTE_PTR, ulSignatureLen: CK_ULONG,
                           pData: CK_BYTE_PTR, pulDataLen: CK_ULONG_PTR)
     -> CK_RV;
    pub fn C_DigestEncryptUpdate(hSession: CK_SESSION_HANDLE,
                                 pPart: CK_BYTE_PTR, ulPartLen: CK_ULONG,
                                 pEncryptedPart: CK_BYTE_PTR,
                                 pulEncryptedPartLen: CK_ULONG_PTR) -> CK_RV;
    pub fn C_DecryptDigestUpdate(hSession: CK_SESSION_HANDLE,
                                 pEncryptedPart: CK_BYTE_PTR,
                                 ulEncryptedPartLen: CK_ULONG,
                                 pPart: CK_BYTE_PTR, pulPartLen: CK_ULONG_PTR)
     -> CK_RV;
    pub fn C_SignEncryptUpdate(hSession: CK_SESSION_HANDLE,
                               pPart: CK_BYTE_PTR, ulPartLen: CK_ULONG,
                               pEncryptedPart: CK_BYTE_PTR,
                               pulEncryptedPartLen: CK_ULONG_PTR) -> CK_RV;
    pub fn C_DecryptVerifyUpdate(hSession: CK_SESSION_HANDLE,
                                 pEncryptedPart: CK_BYTE_PTR,
                                 ulEncryptedPartLen: CK_ULONG,
                                 pPart: CK_BYTE_PTR, pulPartLen: CK_ULONG_PTR)
     -> CK_RV;
    pub fn C_GenerateKey(hSession: CK_SESSION_HANDLE,
                         pMechanism: CK_MECHANISM_PTR,
                         pTemplate: CK_ATTRIBUTE_PTR, ulCount: CK_ULONG,
                         phKey: CK_OBJECT_HANDLE_PTR) -> CK_RV;
    pub fn C_GenerateKeyPair(hSession: CK_SESSION_HANDLE,
                             pMechanism: CK_MECHANISM_PTR,
                             pPublicKeyTemplate: CK_ATTRIBUTE_PTR,
                             ulPublicKeyAttributeCount: CK_ULONG,
                             pPrivateKeyTemplate: CK_ATTRIBUTE_PTR,
                             ulPrivateKeyAttributeCount: CK_ULONG,
                             phPublicKey: CK_OBJECT_HANDLE_PTR,
                             phPrivateKey: CK_OBJECT_HANDLE_PTR) -> CK_RV;
    pub fn C_WrapKey(hSession: CK_SESSION_HANDLE,
                     pMechanism: CK_MECHANISM_PTR,
                     hWrappingKey: CK_OBJECT_HANDLE, hKey: CK_OBJECT_HANDLE,
                     pWrappedKey: CK_BYTE_PTR, pulWrappedKeyLen: CK_ULONG_PTR)
     -> CK_RV;
    pub fn C_UnwrapKey(hSession: CK_SESSION_HANDLE,
                       pMechanism: CK_MECHANISM_PTR,
                       hUnwrappingKey: CK_OBJECT_HANDLE,
                       pWrappedKey: CK_BYTE_PTR, ulWrappedKeyLen: CK_ULONG,
                       pTemplate: CK_ATTRIBUTE_PTR,
                       ulAttributeCount: CK_ULONG,
                       phKey: CK_OBJECT_HANDLE_PTR) -> CK_RV;
    pub fn C_DeriveKey(hSession: CK_SESSION_HANDLE,
                       pMechanism: CK_MECHANISM_PTR,
                       hBaseKey: CK_OBJECT_HANDLE,
                       pTemplate: CK_ATTRIBUTE_PTR,
                       ulAttributeCount: CK_ULONG,
                       phKey: CK_OBJECT_HANDLE_PTR) -> CK_RV;
    pub fn C_SeedRandom(hSession: CK_SESSION_HANDLE, pSeed: CK_BYTE_PTR,
                        ulSeedLen: CK_ULONG) -> CK_RV;
    pub fn C_GenerateRandom(hSession: CK_SESSION_HANDLE,
                            RandomData: CK_BYTE_PTR, ulRandomLen: CK_ULONG)
     -> CK_RV;
    pub fn C_GetFunctionStatus(hSession: CK_SESSION_HANDLE) -> CK_RV;
    pub fn C_CancelFunction(hSession: CK_SESSION_HANDLE) -> CK_RV;
    pub fn C_WaitForSlotEvent(flags: CK_FLAGS, pSlot: CK_SLOT_ID_PTR,
                              pRserved: CK_VOID_PTR) -> CK_RV;
}
